## Example demonstrating REPL from embedded bytecode
## This shows how to use a pre-compiled REPL without needing external files
##
## First run: nimble compile_repl_bytecode
## Then run: nim c -r examples/repl_bytecode.nim

import ../../src/burrito/qjs
import ../../build/qjs/src/repl_bytecode  # Import the generated bytecode
import std/[times, random]

proc getCurrentTime(ctx: ptr JSContext): JSValue =
  ## Return current time as a string  
  nimStringToJS(ctx, now().format("yyyy-MM-dd HH:mm:ss"))

proc randomInt(ctx: ptr JSContext, max: JSValue): JSValue =
  ## Return a random integer between 0 and max
  randomize()
  var maxInt: int32
  if JS_ToInt32(ctx, addr maxInt, max) != 0:
    return JS_ThrowTypeError(ctx, "Expected number argument")
  result = JS_NewInt32(ctx, rand(maxInt).int32)

when isMainModule:
  echo "Starting REPL from embedded bytecode..."
  echo "This REPL includes custom Nim functions:"
  echo "  - getCurrentTime(): Get current timestamp"
  echo "  - randomInt(max): Get random integer between 0 and max"
  echo ""

  # Create QuickJS with full standard library support
  var js = newQuickJS(configWithBothLibs())

  # Register custom Nim functions
  js.registerFunction("getCurrentTime", getCurrentTime)
  js.registerFunction("randomInt", randomInt)

  # Load REPL from bytecode instead of file
  try:
    discard js.evalBytecodeModule(qjsc_replBytecode)
    js.runPendingJobs()
    
    # Start the interactive REPL
    js.processStdLoop()
  except JSException as e:
    echo "Error loading REPL: ", e.msg
  finally:
    js.close()